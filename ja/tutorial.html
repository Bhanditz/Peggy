<!DOCTYPE html>
<head><meta charset="utf-8"><title>Peggy - チュートリアル</title><meta name="description" content="Peggy: The Parser Generator for Haskell"><meta name="author" content="Hideyuki Tanaka"><link rel="stylesheet" href="../bootstrap/bootstrap.css"><link rel="stylesheet" href="../css/default.css"><link rel="stylesheet" href="../google-code-prettify/prettify.css"><script type="text/javascript" src="../google-code-prettify/prettify.js"></script></head><body onload="prettyPrint()"><div class="topbar"><div class="fill"><div class="container"><a class="brand" href="index.html">Peggy</a><ul class="nav"><li><a href="index.html">Home</a></li><li><a href="tutorial.html">Tutorial</a></li><li><a href="syntax.html">Syntax</a></li><li><a href="example.html">Example</a></li><li><a href="haddock/index.html">Reference</a></li><li><a href="https://github.com/tanakh/Peggy">Repository</a></li><li><a href="about.html">About</a></li></ul><div class="pull-right"><ul class="nav"><li><a href="ja/">ja</a></li><li><a href="../">en</a></li></ul></div></div></div></div><div class="container"><div class="content"><div class="page-header"><h1>Peggy - チュートリアル</h1></div><div class="row"><div class="span14">

<h2 id="インストール">インストール</h2>
<p>まず始めに、Peggyをあなたのシステムにインストールしましょう。 既に<a href="http://hackage.haskell.org/platform/">Haskell Platform</a>がインストールされているなら、 次のコマンドをタイプするだけでインストールできます。 Haskell Platformがインストールされていない場合は、 各プラットフォームでの手順に従い、 まずそちらをインストールしてください。</p>
<pre class="prettyprint">$ cabal update
$ cabal install Peggy</pre>
<p>さあ、Peggyが利用できるようになりました。</p>
<h2 id="最初の例">最初の例</h2>
<p>まず、簡単な例を用いて文法を見ていきます。</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}

import Text.Peggy

[peggy|
nums :: [Int]
  = num*
num ::: Int
  = [0-9]+ { read $1 }
|]

main :: IO ()
main = print . parseString nums &quot;&lt;stdin&gt;&quot; =&lt;&lt; getContents</pre>
<p>これは、数の列をパーズするパーザです。 実際に動かしてみましょう。</p>
<pre class="prettyprint">$ cat input 
1 2 3 4 5
$ runhaskell Test.hs &lt; input
Right [1,2,3,4,5]</pre>
<p>正しく動いているようですね(´･_･`)！</p>
<h2 id="haskell言語拡張">Haskell言語拡張</h2>
<p>Peggyを使用するにあたって、最初の行に次のプラグマを書く必要があります。</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}</pre>
<p>これらの拡張は、peggyをEDSLとして使うためと、 peggyが内部的に生成するコードをコンパイルさせるために必要になります。</p>
<h2 id="peggyモジュールのimport">Peggyモジュールのimport</h2>
<p>Peggyを使うためには、Peggyのモジュールをimportする必要があります。 次の一つの行を単純に追加するだけです。</p>
<pre class="prettyprint">import Text.Peggy</pre>
<h2 id="パーザの定義">パーザの定義</h2>
<p>さて、ようやくパーザを書く準備が整いました。 Peggyは embeded DSL (EDSL) スタイルのパーザジェネレータですので、 パーザはHaskellのソースコード中に直に書き込みます。</p>
<p>Peggyはquasi-quoterとして提供されます。 パーザを定義するためには、quasi-quoter [peggy| … |] にて、パーザの定義を囲います。</p>
<pre class="prettyprint">[peggy|
nums :: [Int]
  = num*
... ここに文法を記述
|]</pre>
<p>パーザは定義の集合です。 定義にはPEGのフル機能と、幾つかの独自拡張が利用できます。 Peggyの構文の詳細は<a href="syntax.html">こちら</a>を参照してください。</p>
<h2 id="典型的な定義の形">典型的な定義の形</h2>
<p>典型的な構文定義は次のような形になっています。</p>
<pre class="prettyprint">&lt;name&gt; :: &lt;Haskell-Type&gt;
  = &lt;expr&gt; ... { &lt;semantic-by-haskell-code&gt; }
  / &lt;expr&gt; ... { ... }
  ...</pre>
<p>各定義は幾つかの代替部を持っています。 そしてそのそれぞれは、セマンティクスの付いた式の列になっています。 セマンティクスは、プレースホルダを含む、単一のHaskellの式として表現されます。 これは各非終端記号のパーズ結果の値として用いられます。</p>
<h2 id="トークン字句">トークン（字句）</h2>
<p>Peggyは暗黙的にトークンを扱います。 トークンを定義するには、型名の前のdouble-colon (::) を triple-colon (:::) に変えます。</p>
<pre class="prettyprint">num ::: Int
  = [0-9]+ { read $1 }</pre>
<p>これで、前後の空白を読み飛ばし、デミリタ区切りになりました。 トークンの振る舞いの詳細は<a href="syntax.html#token">構文マニュアル</a>を参照してください。</p>
<h2 id="生成されたパーザ">生成されたパーザ</h2>
<p>Peggyのquasi-quoterは <em>パーザ</em> の集合を生成します。 各非終端記号の定義一つに対し、一つのパーザが定義されます。</p>
<pre class="prettyprint">nums :: Parser [Int] -- これは単純化した型であり、実際の型とは異なります
nums = ... (Haskell code generated by Peggy)</pre>
<h2 id="パーザを起動する">パーザを起動する</h2>
<p>ついに、パーザを動作させる準備が整いました。 次の関数を用いて、任意の文字列をパーズすることができます。</p>
<pre class="prettyprint">parseString :: ListLike str Char
               =&gt; Parser a
               -&gt; String
               -&gt; str
               -&gt; Either ParseError a
parseString parser inputName input =
  ...</pre>
<h2 id="quasi-quoter-を生成する">quasi-quoter を生成する</h2>
<p>Peggyはユーザ定義のquasi-quoterを簡単に生成することができます。</p>
<pre class="prettyprint">module Nums (numsqq) where

genParser [(&quot;numsqq&quot;, &quot;nums&quot;)] [peggy|
nums :: [Int]
  = num*
num ::: Int
  = [0-9]+ { read $1 }
|]</pre>
<p>genParserという関数を用いてパーザの生成を行います。 このとき、第一引数には定義したいquasi-quoterの情報を渡します。 これは、定義するquasi-quoterの名前と、それが利用する非終端記号の名前のペアのリストです。 この場合だと、numsqqというquasi-quoterが生成されます。</p>
<p>Template Haskellの制限により、この定義は利用するモジュールから分離しなければなりません。</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}
import Nums

main :: IO ()
main = print [numsqq| 1 2 3 4 5 |]</pre>
<p>さて、使ってみましょう。</p>
<pre class="prettyprint">$ runhaskell Test.hs
[1, 2, 3, 4, 5]</pre>
<p>期待した動作です。</p>
<h2 id="さらなる学習のために">さらなる学習のために</h2>
<ul>
<li>もう少し複雑な幾つかの例が<a href="example.html">ここ</a>にあります</li>
<li>Peggy構文の完全な記述が<a href="syntax.html">ここ</a>にあります</li>
<li>PeggyによるPeggy文法の自己記述ファイルが<a href="https://github.com/tanakh/Peggy/blob/master/bootstrap/peggy.peggy">ここ</a>にあります。Peggyのパーザは実際にこのファイルからブートストラップされています。</li>
<li>github のレポジトリが<a href="https://github.com/tanakh/Peggy">ここ</a>にあります。パッチ・プルリクエスト大歓迎です。</li>
</ul>
</div>






</div></div><footer><p>Copyright © Hideyuki Tanaka 2011</p></footer></div></body>