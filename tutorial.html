<!DOCTYPE html>
<head><meta charset="utf-8"><title>Peggy - Tutorial</title><meta name="description" content="Peggy: The Parser Generator for Haskell"><meta name="author" content="Hideyuki Tanaka"><link rel="stylesheet" href="./bootstrap/bootstrap.css"><link rel="stylesheet" href="./css/default.css"><link rel="stylesheet" href="./google-code-prettify/prettify.css"><script type="text/javascript" src="./google-code-prettify/prettify.js"></script></head><body onload="prettyPrint()"><div class="topbar"><div class="fill"><div class="container"><a class="brand" href="index.html">Peggy</a><ul class="nav"><li><a href="index.html">Home</a></li><li><a href="tutorial.html">Tutorial</a></li><li><a href="syntax.html">Syntax</a></li><li><a href="example.html">Example</a></li><li><a href="./haddock/index.html">Reference</a></li><li><a href="https://github.com/tanakh/Peggy">Repository</a></li><li><a href="about.html">About</a></li></ul><div class="pull-right"><ul class="nav"><li><a href="./ja/">ja</a></li><li><a href="./">en</a></li></ul></div></div></div></div><div class="container"><div class="content"><div class="page-header"><h1>Peggy - Tutorial</h1></div><div class="row"><div class="span14">

<h2 id="install">Install</h2>
<p>You can install from <a href="http://hackage.haskell.org/package/peggy">Hackage</a>, by using <em>cabal-install</em>.</p>
<pre class="prettyprint">$ cabal update
$ cabal install Peggy</pre>
<p>Now, you can use Peggy!</p>
<h2 id="first-example">First Example</h2>
<p>Here is first example.</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}

import Text.Peggy

[peggy|
nums :: [Int]
  = num*
num ::: Int
  = [0-9]+ { read $1 }
|]

main :: IO ()
main = print . parseString nums &quot;&lt;stdin&gt;&quot; =&lt;&lt; getContents</pre>
<p>It is a parser which parses a sequence of integers. Let’s try it.</p>
<pre class="prettyprint">$ cat input 
1 2 3 4 5
$ runhaskell Test.hs &lt; input
Right [1,2,3,4,5]</pre>
<p>It seems to run correctly :)</p>
<h2 id="language-extensions">Language Extensions</h2>
<p>At first line,</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}</pre>
<p>add these language extensions for using peggy embeded DSL.</p>
<h2 id="import-peggy-module">Import Peggy module</h2>
<p>To use Peggy, you need simply to import Peggy module.</p>
<pre class="prettyprint">import Text.Peggy</pre>
<h2 id="define-a-parser">Define a parser</h2>
<p>Now, you can define your parser. Peggy is embeded DSL (eDSL) style parser generator, so you wrote your parser in a Haskell file directly.</p>
<p>Peggy is provided by Quasi-Quoter. In order to define parser, write a syntax in quasi-quoter [peggy| … |].</p>
<pre class="prettyprint">[peggy|
nums :: [Int]
  = num*
... define syntax here
|]</pre>
<p>A parser is a set of definitions. You can use full PEG syntax and Peggy extensions. A full Peggy syntax is described <a href="./syntax.html">here</a>.</p>
<h2 id="typical-form-of-syntax">Typical form of syntax</h2>
<p>A typical form of syntax definition is</p>
<pre class="prettyprint">&lt;name&gt; :: &lt;Haskell-Type&gt;
  = &lt;expr&gt; ... { &lt;semantic-by-haskell-code&gt; }
  / &lt;expr&gt; ... { ... }
  ...</pre>
<p>Each definition has several alternatives, and each alternative is a sequence of primitive expression with semantic. Semantic is a single haskell expression with place holder. It specify the result value of the nonterminal.</p>
<h2 id="token">Token</h2>
<p>Peggy handles implicit token. You can define a nonterminals as a token by using triple-colon (:::)</p>
<pre class="prettyprint">num ::: Int
  = [0-9]+ { read $1 }</pre>
<p>It allows any leading/trailing spaces. For more detail about token behaviour, please refer to <a href="./syntax.html#token">syntax maual</a>.</p>
<h2 id="generated-parser">Generated parser</h2>
<p>Peggy quasi-quoter generates a set of <em>parsers</em>. Parser is defined for each nonterminal symbol has same name.</p>
<pre class="prettyprint">nums :: Parser [Int] -- It is simplified. Actually, it has more complicated type.
nums = ... (Haskell code generated by Peggy)</pre>
<h2 id="invoking-parser">Invoking parser</h2>
<p>At last, you can invoke your parser by using following function.</p>
<pre class="prettyprint">parseString :: ListLike str Char
               =&gt; Parser a
               -&gt; String
               -&gt; str
               -&gt; Either ParseError a
parseString parser inputName input =
  ...</pre>
<p>It can parse any String-like sequence by passed parser.</p>
<h2 id="generate-quasi-quoter">Generate Quasi-Quoter</h2>
<p>Peggy can generate user defined quasi-quoter easily.</p>
<pre class="prettyprint">module Nums (numsqq) where

genParser [(&quot;numsqq&quot;, &quot;nums&quot;)] [peggy|
nums :: [Int]
  = num*
num ::: Int
  = [0-9]+ { read $1 }
|]</pre>
<p>First argument of genParser is a list of pair, qqname and top-nonterminal. In above example, a quasi-quoter named “numsqq” are defined. It generates a list of integers. Because of a restriction of Template Haskell, you must split definition and use of quasi-quoters.</p>
<pre class="prettyprint">{-# Language TemplateHaskell, QuasiQuotes, FlexibleContexts #-}
import Nums

main :: IO ()
main = print [numsqq| 1 2 3 4 5 |]</pre>
<p>Then, you can use it.</p>
<pre class="prettyprint">$ runhaskell Test.hs
[1, 2, 3, 4, 5]</pre>
<h2 id="learn-more">Learn more</h2>
<ul>
<li>Some example of more complex parsers are <a href="example.html">here</a>.</li>
<li>A full description of Peggy syntax is avaiable <a href="./syntax.html">here</a>.</li>
<li>A self defined Peggy syntax file is <a href="https://github.com/tanakh/Peggy/blob/master/bootstrap/peggy.peggy">here</a>, it is used for bootstrapping peggy parser.</li>
<li>A github repository is <a href="https://github.com/tanakh/Peggy">here</a>. Any patch / pull requests are welcome!</li>
</ul>
</div>





</div></div><footer><p>Copyright © Hideyuki Tanaka 2011</p></footer></div></body>